using SoftLiu.Event;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace SoftLiu.States
{
    public class IngameStateJumpInfo
    {
        public string state;
        public string popup;
        public string tab;
        public string item;
        public bool autoJumpToPopup = true; //this is the default behaviour
        public bool scrollToItem = true;//true=>scroll over time. false->insta-set position.
                                        //Note: at time of writing scrollToItem is integrated for shark scroll view behaviour only!
                                        //See SharksManager::SetSharkToScrollTo, called in SharkSelectState.cs
                                        //CHANGE THIS COMMENT ONCE THAT IS NOT THE CASE ANYMORE
    }

    public class StateMachine : AutoGeneratedSingletonMonobehaviour<StateMachine>
    {
        private struct PopupToPush
        {
            public string name;
            public State.ExitBehaviour exitBehaviour;
            public IngameStateJumpInfo inGameStateJumpInfo;
            public int priority;
            public object[] args;
            public PopupStateTransitioner popupStateTransitioner;
        }
        private List<PopupToPush> m_popupQueue = new List<PopupToPush>();

        private bool m_isStateTransitioning = false;

        private string m_lastStateName = "";

        public bool isStateTransitioning
        {
            get { return m_isStateTransitioning; }
            set { m_isStateTransitioning = value; }
        }
        #region States
        // Map of the avaible states
        protected Dictionary<string, State> m_states = new Dictionary<string, State>();

        // State stack
        protected Stack<State> m_stack = new Stack<State>();

        // Find a state by name
        public State GetStateByName(string name)
        {
            State state = null;
            if (!m_states.TryGetValue(name, out state))
                return null;
            return state;
        }

        public bool IsState<T>() where T : State
        {
            return m_stack.Peek() is T;
        }

        // Add a new state
        public void AddState(string name, State state, params object[] args)
        {
            m_states.Add(name, state);
            state.Register(this, name, args);
        }

#if UNITY_EDITOR
        private Dictionary<string, State> GetStates()
        {
            return m_states;
        }
#endif

        //push to popup queue
        /// <summary>
        /// State owning the popup needs to call TriggerPopupQueue when its ready to activate the queue
        /// </summary>
        /// <param name="name"></param>
        /// <param name="exitBehaviour"></param>
        /// <param name="inGameStateJumpInfo"></param>
        /// <param name="priority"></param>
        /// <param name="args"></param>
        public void PushToPopupQueue(string name, State.ExitBehaviour exitBehaviour, IngameStateJumpInfo inGameStateJumpInfo, int priority, params object[] args)
        {
            PopupToPush popup = new PopupToPush();
            popup.name = name;
            popup.exitBehaviour = exitBehaviour;
            popup.inGameStateJumpInfo = inGameStateJumpInfo;
            popup.priority = priority;
            popup.args = args;
            popup.popupStateTransitioner = null;

            AddToPopupQueue(popup);
        }

        public string GetPopupAtTopOfTheQueue()
        {
            if (m_popupQueue != null && m_popupQueue.Count > 0)
            {
                return m_popupQueue[0].name;
            }
            return null;

        }
        public void PushToPopupQueue(int priority, PopupStateTransitioner popupStateTransitioner)
        {
            PopupToPush popup = new PopupToPush();
            popup.priority = priority;
            popup.popupStateTransitioner = popupStateTransitioner;

            AddToPopupQueue(popup);
        }

        private void AddToPopupQueue(PopupToPush popup)
        {
            m_popupQueue.Add(popup);

            m_popupQueue.Sort(delegate (PopupToPush a, PopupToPush b)
            {
                return a.priority - b.priority;
            });
        }

        public void TriggerPopupQueue()
        {
            PushPopupQueue();
        }

        public bool HasPopupsQueued()
        {
            if (m_popupQueue.Count > 0)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        private void PushPopupQueue()
        {
            if ((GetCurrentState() is PopupState) == false)
            {
                if (m_popupQueue.Count > 0)
                {
                    PopupToPush popupToPush = m_popupQueue[0];
                    m_popupQueue.RemoveAt(0);

                    if (popupToPush.popupStateTransitioner == null)
                    {
                        Push(popupToPush.name, popupToPush.exitBehaviour, popupToPush.inGameStateJumpInfo, popupToPush.args);
                    }
                    else
                    {
                        popupToPush.popupStateTransitioner.PushState();
                    }
                }
            }
        }

        // Push a state
        public virtual State Push(string name, State.ExitBehaviour exitBehaviour, IngameStateJumpInfo inGameStateJumpInfo, params object[] args)
        {
            if (isStateTransitioning)
            {
                Debug.LogWarning(string.Format("StateMachine (Push) :: Can't push state {0} while transitioning to another state!", name));
                return null;
            }
            else
            {
                State state = GetStateByName(name);
                if (state == null)
                {
                    Debug.Log("StateMachine : Unknown state! (\"" + name + "\")");
                    return null;
                }

                m_lastStateName = GetCurrentStateName();

                State oldState = null;
                if (m_stack.Count > 0)
                    oldState = m_stack.Peek();

                // ensure we disable all interactables in the current screen, just as precaution
                //ScreenState root = oldState as ScreenState;
                //if (root != null && root.screenRoot != null)
                //{
                //    Util.SetUiInteractablesEnabled(root.screenRoot.gameObject, false);
                //}

                isStateTransitioning = true;

                m_stack.Push(state);

                // Let the states know
                if (oldState != null)
                    oldState.OnPause(state, exitBehaviour);

                state.OnEnter(oldState, inGameStateJumpInfo, args);

                // send out a notification to anything that's interested
                EventManager<global::Events>.Instance.TriggerEvent(global::Events.StateChange, oldState, state);

#if DEBUG_STATE_MACHINE
                PrintStack();
#endif
                return state;
            }
        }

        public State Pop()
        {
            if (isStateTransitioning)
            {
                Debug.LogWarning("StateMachine (Pop) :: Can't pop state while transitioning to another state!");
                return null;
            }
            else
            {
                return Pop(State.ExitBehaviour.Destroy);
            }
        }

        // Pop a state
        public State Pop(State.ExitBehaviour exitBehaviour, params object[] args)
        {
            if (isStateTransitioning)
            {
                Debug.LogWarning("StateMachine (Pop) :: Can't pop state while transitioning to another state!");
                return null;
            }
            else
            {
                if (m_stack.Count == 0)
                {
                    Debug.Log("StateMachine : Nothing to pop!");
                    return null;
                }

                m_lastStateName = GetCurrentStateName();

                isStateTransitioning = true;

                State oldState = m_stack.Pop();

                // peek fails if stack empty after pop, so only peek if we have something to peek at
                State newState = m_stack.Count >= 1 ? m_stack.Peek() : null;

                // Let the states know
                oldState.OnExit(newState, exitBehaviour);

                if (newState != null)
                {
                    newState.OnResume(oldState, args);
                }

                // send out a notification to anything that's interested
                EventManager<global::Events>.Instance.TriggerEvent(global::Events.StateChange, oldState, newState);

#if DEBUG_STATE_MACHINE
                PrintStack();
#endif

                PushPopupQueue();

                return newState;
            }
        }

        public State SwapState(string name, State.ExitBehaviour exitBehaviour, IngameStateJumpInfo stateJumpInfo, params object[] args)
        {
            if (isStateTransitioning)
            {
                Debug.LogWarning(string.Format("StateMachine (SwapState) :: Can't swap state {0} while transitioning to another state!", name));
                return null;
            }
            else
            {
                if (m_stack.Count == 0)
                {
                    return Push(name, exitBehaviour, stateJumpInfo, args);
                }

                State state = GetStateByName(name);
                if (state == null)
                {
                    Debug.Log("StateMachine : Unknown state! (\"" + name + "\")");
                    return null;
                }

                m_lastStateName = GetCurrentStateName();

                isStateTransitioning = true;

                State oldState = m_stack.Pop();

                // Let the states know
                if (oldState != null)
                    oldState.OnExit(state, exitBehaviour);

                m_stack.Push(state);

                state.OnEnter(oldState, stateJumpInfo, args);

                // send out a notification to anything that's interested
                EventManager<global::Events>.Instance.TriggerEvent(global::Events.StateChange, oldState, state);

#if DEBUG_STATE_MACHINE
                PrintStack();
#endif
                return state;
            }
        }


        public State GetCurrentState()
        {
            return (m_stack.Count > 0) ? m_stack.Peek() : null;
        }

        public string GetCurrentStateName()
        {
            State currentState = GetCurrentState();
            if (currentState != null)
            {
                return currentState.name;
            }
            else
            {
                return "";
            }
        }

        public State GetSecondStateInStack()
        {
            bool discardFirst = true;
            foreach (State state in m_stack)
            {
                //Skip first one
                if (discardFirst)
                {
                    discardFirst = false;
                    continue;
                }

                //REturn second state
                return state;
            }

            return null;
        }

        public int GetNumStates()
        {
            return m_stack.Count;
        }

        public bool DoesStateExistOnStack(string stateName)
        {
            Stack<State>.Enumerator e = m_stack.GetEnumerator();
            while (e.MoveNext())
            {
                if (e.Current.name.Equals(stateName))
                    return true;
            }
            return false;
        }

        public void RemoveStatesInBetween(string oldState)
        {
            State currentTop = m_stack.Peek();

            State top = null;

            while (m_stack.Count > 0)
            {
                top = m_stack.Peek();

                if (top.name.Equals(oldState))
                {
                    m_stack.Push(currentTop);
                    break;
                }
                else
                {
                    m_stack.Pop();
                }
            }
        }

        public void PopUntilState(string stateName, State.ExitBehaviour exitBehaviour, params object[] args)
        {
            if (isStateTransitioning)
            {
                Debug.LogWarning(string.Format("StateMachine (PopUntilState) :: Can't PopUntilState {0} while transitioning to another state!", stateName));
                return;
            }
            else
            {
                State currentTop = m_stack.Peek();

                State top = null;
                State oldState = null;

                isStateTransitioning = true;

                while (m_stack.Count > 0)
                {
                    top = m_stack.Peek();

                    if (top.name.Equals(stateName))
                    {
                        // tell this state that we're resuming, but if it needs to know where it came from, supply it the original state from where we came
                        // not any of the intermediate states
                        top.OnResume(currentTop, args);
                        break;
                    }
                    else
                    {
                        oldState = m_stack.Pop();
                        m_lastStateName = oldState.name;

                        // peek fails if stack empty after pop, so only peek if we have something to peek at
                        State newState = m_stack.Count > 0 ? m_stack.Peek() : null;

                        // Let the old state know, in case it needs to take any action based on this?
                        oldState.OnExit(newState, exitBehaviour);
                    }
                }

                // send out a notification to anything that's interested
                EventManager<Events>.Instance.TriggerEvent(Events.StateChange, oldState, top);

#if DEBUG_STATE_MACHINE
                PrintStack();
#endif
            }
        }

        public void CleanPopupQueue()
        {
            if (m_popupQueue != null)
            {
                m_popupQueue.Clear();
            }
        }

        public T GetLastState<T>() where T : State
        {
            // go backwards through the stack until we hit a T state
            T oldState = null;
            Stack<State>.Enumerator e = m_stack.GetEnumerator();
            while (e.MoveNext())
            {
                State state = e.Current;
                if (state is T)
                {
                    oldState = (T)e.Current;
                    break;
                }
            }

            return oldState;
        }

        public string GetLastStateName()
        {
            return m_lastStateName;
        }

        public void OnApplicationPause(bool pause)
        {
            if (m_stack.Count > 0)
            {
                State currentTop = m_stack.Peek();
                currentTop.OnApplicationPause(pause);
            }
        }

        protected void ClearActiveStates()
        {
            m_stack.Clear();

#if DEBUG_STATE_MACHINE
		    PrintStack();
#endif
        }

        // helper
        public void PrintStack()
        {
            string stackStr = "";

            Stack<State>.Enumerator e = m_stack.GetEnumerator();
            while (e.MoveNext())
            {
                stackStr += (e.Current.name) + "|";
            }

            Debug.Log("Stack status: " + stackStr);
        }

        #endregion
        #region Updates
        protected virtual void PreUpdate() { }
        protected virtual void PostUpdate() { }
        protected virtual void DoUpdate()
        {
            if (m_stack.Count > 0)
            {
                State state = m_stack.Peek();
                if (state != null)
                {
                    state.OnUpdate();
                }
            }
        }

        public virtual void Update()
        {
            PreUpdate();
            DoUpdate();
            PostUpdate();
        }

        protected virtual void PreFixedUpdate() { }
        protected virtual void PostFixedUpdate() { }
        protected virtual void DoFixedUpdate() { }

        void FixedUpdate()
        {
            PreFixedUpdate();
            DoFixedUpdate();
            PostFixedUpdate();
        }

        protected virtual void PreLateUpdate() { }
        protected virtual void PostLateUpdate() { }
        protected virtual void DoLateUpdate() { }

        void LateUpdate()
        {
            PreLateUpdate();
            DoLateUpdate();
            PostLateUpdate();
        }

        #endregion
    }
}
